// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: test.proto
// Protobuf C++ Version: 5.29.5

#ifndef test_2eproto_2epb_2eh
#define test_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029005
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_test_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_test_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_test_2eproto;
class AttackMessage;
struct AttackMessageDefaultTypeInternal;
extern AttackMessageDefaultTypeInternal _AttackMessage_default_instance_;
class AttackSpeedSyncMessage;
struct AttackSpeedSyncMessageDefaultTypeInternal;
extern AttackSpeedSyncMessageDefaultTypeInternal _AttackSpeedSyncMessage_default_instance_;
class AttackSyncMessage;
struct AttackSyncMessageDefaultTypeInternal;
extern AttackSyncMessageDefaultTypeInternal _AttackSyncMessage_default_instance_;
class ExecuteSkillMessage;
struct ExecuteSkillMessageDefaultTypeInternal;
extern ExecuteSkillMessageDefaultTypeInternal _ExecuteSkillMessage_default_instance_;
class ExitSyncMessage;
struct ExitSyncMessageDefaultTypeInternal;
extern ExitSyncMessageDefaultTypeInternal _ExitSyncMessage_default_instance_;
class HealthSyncMessage;
struct HealthSyncMessageDefaultTypeInternal;
extern HealthSyncMessageDefaultTypeInternal _HealthSyncMessage_default_instance_;
class InputPacket;
struct InputPacketDefaultTypeInternal;
extern InputPacketDefaultTypeInternal _InputPacket_default_instance_;
class ManaSyncMessage;
struct ManaSyncMessageDefaultTypeInternal;
extern ManaSyncMessageDefaultTypeInternal _ManaSyncMessage_default_instance_;
class MoveMessage;
struct MoveMessageDefaultTypeInternal;
extern MoveMessageDefaultTypeInternal _MoveMessage_default_instance_;
class ObjectsDestroyedSyncMessage;
struct ObjectsDestroyedSyncMessageDefaultTypeInternal;
extern ObjectsDestroyedSyncMessageDefaultTypeInternal _ObjectsDestroyedSyncMessage_default_instance_;
class Packet;
struct PacketDefaultTypeInternal;
extern PacketDefaultTypeInternal _Packet_default_instance_;
class PlayerSyncMessage;
struct PlayerSyncMessageDefaultTypeInternal;
extern PlayerSyncMessageDefaultTypeInternal _PlayerSyncMessage_default_instance_;
class PlayerUseSkillMessage;
struct PlayerUseSkillMessageDefaultTypeInternal;
extern PlayerUseSkillMessageDefaultTypeInternal _PlayerUseSkillMessage_default_instance_;
class PositionSyncMessage;
struct PositionSyncMessageDefaultTypeInternal;
extern PositionSyncMessageDefaultTypeInternal _PositionSyncMessage_default_instance_;
class SkillInfoMessage;
struct SkillInfoMessageDefaultTypeInternal;
extern SkillInfoMessageDefaultTypeInternal _SkillInfoMessage_default_instance_;
class SyncSkillMessage;
struct SyncSkillMessageDefaultTypeInternal;
extern SyncSkillMessageDefaultTypeInternal _SyncSkillMessage_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google


// ===================================================================


// -------------------------------------------------------------------

class SkillInfoMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SkillInfoMessage) */ {
 public:
  inline SkillInfoMessage() : SkillInfoMessage(nullptr) {}
  ~SkillInfoMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SkillInfoMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SkillInfoMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SkillInfoMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline SkillInfoMessage(const SkillInfoMessage& from) : SkillInfoMessage(nullptr, from) {}
  inline SkillInfoMessage(SkillInfoMessage&& from) noexcept
      : SkillInfoMessage(nullptr, std::move(from)) {}
  inline SkillInfoMessage& operator=(const SkillInfoMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillInfoMessage& operator=(SkillInfoMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillInfoMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SkillInfoMessage* internal_default_instance() {
    return reinterpret_cast<const SkillInfoMessage*>(
        &_SkillInfoMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SkillInfoMessage& a, SkillInfoMessage& b) { a.Swap(&b); }
  inline void Swap(SkillInfoMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillInfoMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillInfoMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SkillInfoMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SkillInfoMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SkillInfoMessage& from) { SkillInfoMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SkillInfoMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "SkillInfoMessage"; }

 protected:
  explicit SkillInfoMessage(::google::protobuf::Arena* arena);
  SkillInfoMessage(::google::protobuf::Arena* arena, const SkillInfoMessage& from);
  SkillInfoMessage(::google::protobuf::Arena* arena, SkillInfoMessage&& from) noexcept
      : SkillInfoMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kAngleFieldNumber = 4,
  };
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // float angle = 4;
  void clear_angle() ;
  float angle() const;
  void set_angle(float value);

  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);

  public:
  // @@protoc_insertion_point(class_scope:SkillInfoMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SkillInfoMessage& from_msg);
    ::uint64_t id_;
    float angle_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class PositionSyncMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PositionSyncMessage) */ {
 public:
  inline PositionSyncMessage() : PositionSyncMessage(nullptr) {}
  ~PositionSyncMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PositionSyncMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PositionSyncMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PositionSyncMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline PositionSyncMessage(const PositionSyncMessage& from) : PositionSyncMessage(nullptr, from) {}
  inline PositionSyncMessage(PositionSyncMessage&& from) noexcept
      : PositionSyncMessage(nullptr, std::move(from)) {}
  inline PositionSyncMessage& operator=(const PositionSyncMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionSyncMessage& operator=(PositionSyncMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionSyncMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionSyncMessage* internal_default_instance() {
    return reinterpret_cast<const PositionSyncMessage*>(
        &_PositionSyncMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(PositionSyncMessage& a, PositionSyncMessage& b) { a.Swap(&b); }
  inline void Swap(PositionSyncMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionSyncMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionSyncMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PositionSyncMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionSyncMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PositionSyncMessage& from) { PositionSyncMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PositionSyncMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "PositionSyncMessage"; }

 protected:
  explicit PositionSyncMessage(::google::protobuf::Arena* arena);
  PositionSyncMessage(::google::protobuf::Arena* arena, const PositionSyncMessage& from);
  PositionSyncMessage(::google::protobuf::Arena* arena, PositionSyncMessage&& from) noexcept
      : PositionSyncMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kPosXFieldNumber = 2,
    kPosYFieldNumber = 3,
  };
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // float pos_x = 2;
  void clear_pos_x() ;
  float pos_x() const;
  void set_pos_x(float value);

  private:
  float _internal_pos_x() const;
  void _internal_set_pos_x(float value);

  public:
  // float pos_y = 3;
  void clear_pos_y() ;
  float pos_y() const;
  void set_pos_y(float value);

  private:
  float _internal_pos_y() const;
  void _internal_set_pos_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:PositionSyncMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PositionSyncMessage& from_msg);
    ::uint64_t id_;
    float pos_x_;
    float pos_y_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class PlayerUseSkillMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlayerUseSkillMessage) */ {
 public:
  inline PlayerUseSkillMessage() : PlayerUseSkillMessage(nullptr) {}
  ~PlayerUseSkillMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerUseSkillMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerUseSkillMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerUseSkillMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerUseSkillMessage(const PlayerUseSkillMessage& from) : PlayerUseSkillMessage(nullptr, from) {}
  inline PlayerUseSkillMessage(PlayerUseSkillMessage&& from) noexcept
      : PlayerUseSkillMessage(nullptr, std::move(from)) {}
  inline PlayerUseSkillMessage& operator=(const PlayerUseSkillMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerUseSkillMessage& operator=(PlayerUseSkillMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerUseSkillMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerUseSkillMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerUseSkillMessage*>(
        &_PlayerUseSkillMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(PlayerUseSkillMessage& a, PlayerUseSkillMessage& b) { a.Swap(&b); }
  inline void Swap(PlayerUseSkillMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerUseSkillMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerUseSkillMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerUseSkillMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerUseSkillMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerUseSkillMessage& from) { PlayerUseSkillMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerUseSkillMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "PlayerUseSkillMessage"; }

 protected:
  explicit PlayerUseSkillMessage(::google::protobuf::Arena* arena);
  PlayerUseSkillMessage(::google::protobuf::Arena* arena, const PlayerUseSkillMessage& from);
  PlayerUseSkillMessage(::google::protobuf::Arena* arena, PlayerUseSkillMessage&& from) noexcept
      : PlayerUseSkillMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetPlayerFieldNumber = 2,
    kSkillPosFieldNumber = 1,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
  };
  // uint64 target_player = 2;
  void clear_target_player() ;
  ::uint64_t target_player() const;
  void set_target_player(::uint64_t value);

  private:
  ::uint64_t _internal_target_player() const;
  void _internal_set_target_player(::uint64_t value);

  public:
  // uint32 skill_pos = 1;
  void clear_skill_pos() ;
  ::uint32_t skill_pos() const;
  void set_skill_pos(::uint32_t value);

  private:
  ::uint32_t _internal_skill_pos() const;
  void _internal_set_skill_pos(::uint32_t value);

  public:
  // float x = 3;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 4;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:PlayerUseSkillMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerUseSkillMessage& from_msg);
    ::uint64_t target_player_;
    ::uint32_t skill_pos_;
    float x_;
    float y_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class PlayerSyncMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlayerSyncMessage) */ {
 public:
  inline PlayerSyncMessage() : PlayerSyncMessage(nullptr) {}
  ~PlayerSyncMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerSyncMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerSyncMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerSyncMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerSyncMessage(const PlayerSyncMessage& from) : PlayerSyncMessage(nullptr, from) {}
  inline PlayerSyncMessage(PlayerSyncMessage&& from) noexcept
      : PlayerSyncMessage(nullptr, std::move(from)) {}
  inline PlayerSyncMessage& operator=(const PlayerSyncMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerSyncMessage& operator=(PlayerSyncMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerSyncMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerSyncMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerSyncMessage*>(
        &_PlayerSyncMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(PlayerSyncMessage& a, PlayerSyncMessage& b) { a.Swap(&b); }
  inline void Swap(PlayerSyncMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerSyncMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerSyncMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerSyncMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerSyncMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerSyncMessage& from) { PlayerSyncMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerSyncMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "PlayerSyncMessage"; }

 protected:
  explicit PlayerSyncMessage(::google::protobuf::Arena* arena);
  PlayerSyncMessage(::google::protobuf::Arena* arena, const PlayerSyncMessage& from);
  PlayerSyncMessage(::google::protobuf::Arena* arena, PlayerSyncMessage&& from) noexcept
      : PlayerSyncMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
    kSelfFieldNumber = 2,
  };
  // uint64 uid = 1;
  void clear_uid() ;
  ::uint64_t uid() const;
  void set_uid(::uint64_t value);

  private:
  ::uint64_t _internal_uid() const;
  void _internal_set_uid(::uint64_t value);

  public:
  // bool self = 2;
  void clear_self() ;
  bool self() const;
  void set_self(bool value);

  private:
  bool _internal_self() const;
  void _internal_set_self(bool value);

  public:
  // @@protoc_insertion_point(class_scope:PlayerSyncMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerSyncMessage& from_msg);
    ::uint64_t uid_;
    bool self_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class ObjectsDestroyedSyncMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ObjectsDestroyedSyncMessage) */ {
 public:
  inline ObjectsDestroyedSyncMessage() : ObjectsDestroyedSyncMessage(nullptr) {}
  ~ObjectsDestroyedSyncMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ObjectsDestroyedSyncMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ObjectsDestroyedSyncMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectsDestroyedSyncMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectsDestroyedSyncMessage(const ObjectsDestroyedSyncMessage& from) : ObjectsDestroyedSyncMessage(nullptr, from) {}
  inline ObjectsDestroyedSyncMessage(ObjectsDestroyedSyncMessage&& from) noexcept
      : ObjectsDestroyedSyncMessage(nullptr, std::move(from)) {}
  inline ObjectsDestroyedSyncMessage& operator=(const ObjectsDestroyedSyncMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectsDestroyedSyncMessage& operator=(ObjectsDestroyedSyncMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectsDestroyedSyncMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectsDestroyedSyncMessage* internal_default_instance() {
    return reinterpret_cast<const ObjectsDestroyedSyncMessage*>(
        &_ObjectsDestroyedSyncMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ObjectsDestroyedSyncMessage& a, ObjectsDestroyedSyncMessage& b) { a.Swap(&b); }
  inline void Swap(ObjectsDestroyedSyncMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectsDestroyedSyncMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectsDestroyedSyncMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ObjectsDestroyedSyncMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectsDestroyedSyncMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectsDestroyedSyncMessage& from) { ObjectsDestroyedSyncMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ObjectsDestroyedSyncMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ObjectsDestroyedSyncMessage"; }

 protected:
  explicit ObjectsDestroyedSyncMessage(::google::protobuf::Arena* arena);
  ObjectsDestroyedSyncMessage(::google::protobuf::Arena* arena, const ObjectsDestroyedSyncMessage& from);
  ObjectsDestroyedSyncMessage(::google::protobuf::Arena* arena, ObjectsDestroyedSyncMessage&& from) noexcept
      : ObjectsDestroyedSyncMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ObjectsDestroyedSyncMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectsDestroyedSyncMessage& from_msg);
    ::uint64_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class MoveMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MoveMessage) */ {
 public:
  inline MoveMessage() : MoveMessage(nullptr) {}
  ~MoveMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MoveMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MoveMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline MoveMessage(const MoveMessage& from) : MoveMessage(nullptr, from) {}
  inline MoveMessage(MoveMessage&& from) noexcept
      : MoveMessage(nullptr, std::move(from)) {}
  inline MoveMessage& operator=(const MoveMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveMessage& operator=(MoveMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveMessage* internal_default_instance() {
    return reinterpret_cast<const MoveMessage*>(
        &_MoveMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(MoveMessage& a, MoveMessage& b) { a.Swap(&b); }
  inline void Swap(MoveMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MoveMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveMessage& from) { MoveMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MoveMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "MoveMessage"; }

 protected:
  explicit MoveMessage(::google::protobuf::Arena* arena);
  MoveMessage(::google::protobuf::Arena* arena, const MoveMessage& from);
  MoveMessage(::google::protobuf::Arena* arena, MoveMessage&& from) noexcept
      : MoveMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:MoveMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MoveMessage& from_msg);
    float x_;
    float y_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class ManaSyncMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ManaSyncMessage) */ {
 public:
  inline ManaSyncMessage() : ManaSyncMessage(nullptr) {}
  ~ManaSyncMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ManaSyncMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ManaSyncMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ManaSyncMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ManaSyncMessage(const ManaSyncMessage& from) : ManaSyncMessage(nullptr, from) {}
  inline ManaSyncMessage(ManaSyncMessage&& from) noexcept
      : ManaSyncMessage(nullptr, std::move(from)) {}
  inline ManaSyncMessage& operator=(const ManaSyncMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManaSyncMessage& operator=(ManaSyncMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManaSyncMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManaSyncMessage* internal_default_instance() {
    return reinterpret_cast<const ManaSyncMessage*>(
        &_ManaSyncMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ManaSyncMessage& a, ManaSyncMessage& b) { a.Swap(&b); }
  inline void Swap(ManaSyncMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManaSyncMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManaSyncMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ManaSyncMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ManaSyncMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ManaSyncMessage& from) { ManaSyncMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ManaSyncMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ManaSyncMessage"; }

 protected:
  explicit ManaSyncMessage(::google::protobuf::Arena* arena);
  ManaSyncMessage(::google::protobuf::Arena* arena, const ManaSyncMessage& from);
  ManaSyncMessage(::google::protobuf::Arena* arena, ManaSyncMessage&& from) noexcept
      : ManaSyncMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
    kManaFieldNumber = 2,
    kMaxManaFieldNumber = 3,
  };
  // uint64 uid = 1;
  void clear_uid() ;
  ::uint64_t uid() const;
  void set_uid(::uint64_t value);

  private:
  ::uint64_t _internal_uid() const;
  void _internal_set_uid(::uint64_t value);

  public:
  // int32 mana = 2;
  void clear_mana() ;
  ::int32_t mana() const;
  void set_mana(::int32_t value);

  private:
  ::int32_t _internal_mana() const;
  void _internal_set_mana(::int32_t value);

  public:
  // int32 max_mana = 3;
  void clear_max_mana() ;
  ::int32_t max_mana() const;
  void set_max_mana(::int32_t value);

  private:
  ::int32_t _internal_max_mana() const;
  void _internal_set_max_mana(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ManaSyncMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ManaSyncMessage& from_msg);
    ::uint64_t uid_;
    ::int32_t mana_;
    ::int32_t max_mana_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class HealthSyncMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:HealthSyncMessage) */ {
 public:
  inline HealthSyncMessage() : HealthSyncMessage(nullptr) {}
  ~HealthSyncMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HealthSyncMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HealthSyncMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HealthSyncMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline HealthSyncMessage(const HealthSyncMessage& from) : HealthSyncMessage(nullptr, from) {}
  inline HealthSyncMessage(HealthSyncMessage&& from) noexcept
      : HealthSyncMessage(nullptr, std::move(from)) {}
  inline HealthSyncMessage& operator=(const HealthSyncMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthSyncMessage& operator=(HealthSyncMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthSyncMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthSyncMessage* internal_default_instance() {
    return reinterpret_cast<const HealthSyncMessage*>(
        &_HealthSyncMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(HealthSyncMessage& a, HealthSyncMessage& b) { a.Swap(&b); }
  inline void Swap(HealthSyncMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthSyncMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthSyncMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HealthSyncMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HealthSyncMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HealthSyncMessage& from) { HealthSyncMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HealthSyncMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "HealthSyncMessage"; }

 protected:
  explicit HealthSyncMessage(::google::protobuf::Arena* arena);
  HealthSyncMessage(::google::protobuf::Arena* arena, const HealthSyncMessage& from);
  HealthSyncMessage(::google::protobuf::Arena* arena, HealthSyncMessage&& from) noexcept
      : HealthSyncMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
    kHealthFieldNumber = 2,
    kMaxHealthFieldNumber = 3,
  };
  // uint64 uid = 1;
  void clear_uid() ;
  ::uint64_t uid() const;
  void set_uid(::uint64_t value);

  private:
  ::uint64_t _internal_uid() const;
  void _internal_set_uid(::uint64_t value);

  public:
  // int32 health = 2;
  void clear_health() ;
  ::int32_t health() const;
  void set_health(::int32_t value);

  private:
  ::int32_t _internal_health() const;
  void _internal_set_health(::int32_t value);

  public:
  // int32 max_health = 3;
  void clear_max_health() ;
  ::int32_t max_health() const;
  void set_max_health(::int32_t value);

  private:
  ::int32_t _internal_max_health() const;
  void _internal_set_max_health(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HealthSyncMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HealthSyncMessage& from_msg);
    ::uint64_t uid_;
    ::int32_t health_;
    ::int32_t max_health_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class ExitSyncMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ExitSyncMessage) */ {
 public:
  inline ExitSyncMessage() : ExitSyncMessage(nullptr) {}
  ~ExitSyncMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExitSyncMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExitSyncMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExitSyncMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExitSyncMessage(const ExitSyncMessage& from) : ExitSyncMessage(nullptr, from) {}
  inline ExitSyncMessage(ExitSyncMessage&& from) noexcept
      : ExitSyncMessage(nullptr, std::move(from)) {}
  inline ExitSyncMessage& operator=(const ExitSyncMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExitSyncMessage& operator=(ExitSyncMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExitSyncMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExitSyncMessage* internal_default_instance() {
    return reinterpret_cast<const ExitSyncMessage*>(
        &_ExitSyncMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ExitSyncMessage& a, ExitSyncMessage& b) { a.Swap(&b); }
  inline void Swap(ExitSyncMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExitSyncMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExitSyncMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExitSyncMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExitSyncMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExitSyncMessage& from) { ExitSyncMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExitSyncMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ExitSyncMessage"; }

 protected:
  explicit ExitSyncMessage(::google::protobuf::Arena* arena);
  ExitSyncMessage(::google::protobuf::Arena* arena, const ExitSyncMessage& from);
  ExitSyncMessage(::google::protobuf::Arena* arena, ExitSyncMessage&& from) noexcept
      : ExitSyncMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
  };
  // uint64 uid = 1;
  void clear_uid() ;
  ::uint64_t uid() const;
  void set_uid(::uint64_t value);

  private:
  ::uint64_t _internal_uid() const;
  void _internal_set_uid(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ExitSyncMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExitSyncMessage& from_msg);
    ::uint64_t uid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class ExecuteSkillMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ExecuteSkillMessage) */ {
 public:
  inline ExecuteSkillMessage() : ExecuteSkillMessage(nullptr) {}
  ~ExecuteSkillMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExecuteSkillMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExecuteSkillMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExecuteSkillMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExecuteSkillMessage(const ExecuteSkillMessage& from) : ExecuteSkillMessage(nullptr, from) {}
  inline ExecuteSkillMessage(ExecuteSkillMessage&& from) noexcept
      : ExecuteSkillMessage(nullptr, std::move(from)) {}
  inline ExecuteSkillMessage& operator=(const ExecuteSkillMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteSkillMessage& operator=(ExecuteSkillMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteSkillMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteSkillMessage* internal_default_instance() {
    return reinterpret_cast<const ExecuteSkillMessage*>(
        &_ExecuteSkillMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ExecuteSkillMessage& a, ExecuteSkillMessage& b) { a.Swap(&b); }
  inline void Swap(ExecuteSkillMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteSkillMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteSkillMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExecuteSkillMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExecuteSkillMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExecuteSkillMessage& from) { ExecuteSkillMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExecuteSkillMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ExecuteSkillMessage"; }

 protected:
  explicit ExecuteSkillMessage(::google::protobuf::Arena* arena);
  ExecuteSkillMessage(::google::protobuf::Arena* arena, const ExecuteSkillMessage& from);
  ExecuteSkillMessage(::google::protobuf::Arena* arena, ExecuteSkillMessage&& from) noexcept
      : ExecuteSkillMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRotateFieldNumber = 1,
    kPosXFieldNumber = 2,
    kPosYFieldNumber = 3,
  };
  // float rotate = 1;
  void clear_rotate() ;
  float rotate() const;
  void set_rotate(float value);

  private:
  float _internal_rotate() const;
  void _internal_set_rotate(float value);

  public:
  // float pos_x = 2;
  void clear_pos_x() ;
  float pos_x() const;
  void set_pos_x(float value);

  private:
  float _internal_pos_x() const;
  void _internal_set_pos_x(float value);

  public:
  // float pos_y = 3;
  void clear_pos_y() ;
  float pos_y() const;
  void set_pos_y(float value);

  private:
  float _internal_pos_y() const;
  void _internal_set_pos_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:ExecuteSkillMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExecuteSkillMessage& from_msg);
    float rotate_;
    float pos_x_;
    float pos_y_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class AttackSyncMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AttackSyncMessage) */ {
 public:
  inline AttackSyncMessage() : AttackSyncMessage(nullptr) {}
  ~AttackSyncMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackSyncMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackSyncMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackSyncMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline AttackSyncMessage(const AttackSyncMessage& from) : AttackSyncMessage(nullptr, from) {}
  inline AttackSyncMessage(AttackSyncMessage&& from) noexcept
      : AttackSyncMessage(nullptr, std::move(from)) {}
  inline AttackSyncMessage& operator=(const AttackSyncMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackSyncMessage& operator=(AttackSyncMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackSyncMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttackSyncMessage* internal_default_instance() {
    return reinterpret_cast<const AttackSyncMessage*>(
        &_AttackSyncMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(AttackSyncMessage& a, AttackSyncMessage& b) { a.Swap(&b); }
  inline void Swap(AttackSyncMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackSyncMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackSyncMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackSyncMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackSyncMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackSyncMessage& from) { AttackSyncMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackSyncMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AttackSyncMessage"; }

 protected:
  explicit AttackSyncMessage(::google::protobuf::Arena* arena);
  AttackSyncMessage(::google::protobuf::Arena* arena, const AttackSyncMessage& from);
  AttackSyncMessage(::google::protobuf::Arena* arena, AttackSyncMessage&& from) noexcept
      : AttackSyncMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kCoolDownFieldNumber = 3,
  };
  // uint64 from = 1;
  void clear_from() ;
  ::uint64_t from() const;
  void set_from(::uint64_t value);

  private:
  ::uint64_t _internal_from() const;
  void _internal_set_from(::uint64_t value);

  public:
  // uint64 to = 2;
  void clear_to() ;
  ::uint64_t to() const;
  void set_to(::uint64_t value);

  private:
  ::uint64_t _internal_to() const;
  void _internal_set_to(::uint64_t value);

  public:
  // float cool_down = 3;
  void clear_cool_down() ;
  float cool_down() const;
  void set_cool_down(float value);

  private:
  float _internal_cool_down() const;
  void _internal_set_cool_down(float value);

  public:
  // @@protoc_insertion_point(class_scope:AttackSyncMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AttackSyncMessage& from_msg);
    ::uint64_t from_;
    ::uint64_t to_;
    float cool_down_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class AttackSpeedSyncMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AttackSpeedSyncMessage) */ {
 public:
  inline AttackSpeedSyncMessage() : AttackSpeedSyncMessage(nullptr) {}
  ~AttackSpeedSyncMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackSpeedSyncMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackSpeedSyncMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackSpeedSyncMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline AttackSpeedSyncMessage(const AttackSpeedSyncMessage& from) : AttackSpeedSyncMessage(nullptr, from) {}
  inline AttackSpeedSyncMessage(AttackSpeedSyncMessage&& from) noexcept
      : AttackSpeedSyncMessage(nullptr, std::move(from)) {}
  inline AttackSpeedSyncMessage& operator=(const AttackSpeedSyncMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackSpeedSyncMessage& operator=(AttackSpeedSyncMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackSpeedSyncMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttackSpeedSyncMessage* internal_default_instance() {
    return reinterpret_cast<const AttackSpeedSyncMessage*>(
        &_AttackSpeedSyncMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(AttackSpeedSyncMessage& a, AttackSpeedSyncMessage& b) { a.Swap(&b); }
  inline void Swap(AttackSpeedSyncMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackSpeedSyncMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackSpeedSyncMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackSpeedSyncMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackSpeedSyncMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackSpeedSyncMessage& from) { AttackSpeedSyncMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackSpeedSyncMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AttackSpeedSyncMessage"; }

 protected:
  explicit AttackSpeedSyncMessage(::google::protobuf::Arena* arena);
  AttackSpeedSyncMessage(::google::protobuf::Arena* arena, const AttackSpeedSyncMessage& from);
  AttackSpeedSyncMessage(::google::protobuf::Arena* arena, AttackSpeedSyncMessage&& from) noexcept
      : AttackSpeedSyncMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
    kSpeedFieldNumber = 2,
  };
  // uint64 uid = 1;
  void clear_uid() ;
  ::uint64_t uid() const;
  void set_uid(::uint64_t value);

  private:
  ::uint64_t _internal_uid() const;
  void _internal_set_uid(::uint64_t value);

  public:
  // float speed = 2;
  void clear_speed() ;
  float speed() const;
  void set_speed(float value);

  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);

  public:
  // @@protoc_insertion_point(class_scope:AttackSpeedSyncMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AttackSpeedSyncMessage& from_msg);
    ::uint64_t uid_;
    float speed_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class AttackMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AttackMessage) */ {
 public:
  inline AttackMessage() : AttackMessage(nullptr) {}
  ~AttackMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline AttackMessage(const AttackMessage& from) : AttackMessage(nullptr, from) {}
  inline AttackMessage(AttackMessage&& from) noexcept
      : AttackMessage(nullptr, std::move(from)) {}
  inline AttackMessage& operator=(const AttackMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackMessage& operator=(AttackMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttackMessage* internal_default_instance() {
    return reinterpret_cast<const AttackMessage*>(
        &_AttackMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(AttackMessage& a, AttackMessage& b) { a.Swap(&b); }
  inline void Swap(AttackMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackMessage& from) { AttackMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AttackMessage"; }

 protected:
  explicit AttackMessage(::google::protobuf::Arena* arena);
  AttackMessage(::google::protobuf::Arena* arena, const AttackMessage& from);
  AttackMessage(::google::protobuf::Arena* arena, AttackMessage&& from) noexcept
      : AttackMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
  };
  // uint64 uid = 1;
  void clear_uid() ;
  ::uint64_t uid() const;
  void set_uid(::uint64_t value);

  private:
  ::uint64_t _internal_uid() const;
  void _internal_set_uid(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:AttackMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AttackMessage& from_msg);
    ::uint64_t uid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class SyncSkillMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SyncSkillMessage) */ {
 public:
  inline SyncSkillMessage() : SyncSkillMessage(nullptr) {}
  ~SyncSkillMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SyncSkillMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SyncSkillMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SyncSkillMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline SyncSkillMessage(const SyncSkillMessage& from) : SyncSkillMessage(nullptr, from) {}
  inline SyncSkillMessage(SyncSkillMessage&& from) noexcept
      : SyncSkillMessage(nullptr, std::move(from)) {}
  inline SyncSkillMessage& operator=(const SyncSkillMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncSkillMessage& operator=(SyncSkillMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncSkillMessage& default_instance() {
    return *internal_default_instance();
  }
  enum InfosCase {
    kSkillInfo = 3,
    INFOS_NOT_SET = 0,
  };
  static inline const SyncSkillMessage* internal_default_instance() {
    return reinterpret_cast<const SyncSkillMessage*>(
        &_SyncSkillMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SyncSkillMessage& a, SyncSkillMessage& b) { a.Swap(&b); }
  inline void Swap(SyncSkillMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncSkillMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncSkillMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SyncSkillMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SyncSkillMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SyncSkillMessage& from) { SyncSkillMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SyncSkillMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "SyncSkillMessage"; }

 protected:
  explicit SyncSkillMessage(::google::protobuf::Arena* arena);
  SyncSkillMessage(::google::protobuf::Arena* arena, const SyncSkillMessage& from);
  SyncSkillMessage(::google::protobuf::Arena* arena, SyncSkillMessage&& from) noexcept
      : SyncSkillMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
    kPosFieldNumber = 2,
    kSkillInfoFieldNumber = 3,
  };
  // uint64 uid = 1;
  void clear_uid() ;
  ::uint64_t uid() const;
  void set_uid(::uint64_t value);

  private:
  ::uint64_t _internal_uid() const;
  void _internal_set_uid(::uint64_t value);

  public:
  // int32 pos = 2;
  void clear_pos() ;
  ::int32_t pos() const;
  void set_pos(::int32_t value);

  private:
  ::int32_t _internal_pos() const;
  void _internal_set_pos(::int32_t value);

  public:
  // .SkillInfoMessage skill_info = 3;
  bool has_skill_info() const;
  private:
  bool _internal_has_skill_info() const;

  public:
  void clear_skill_info() ;
  const ::SkillInfoMessage& skill_info() const;
  PROTOBUF_NODISCARD ::SkillInfoMessage* release_skill_info();
  ::SkillInfoMessage* mutable_skill_info();
  void set_allocated_skill_info(::SkillInfoMessage* value);
  void unsafe_arena_set_allocated_skill_info(::SkillInfoMessage* value);
  ::SkillInfoMessage* unsafe_arena_release_skill_info();

  private:
  const ::SkillInfoMessage& _internal_skill_info() const;
  ::SkillInfoMessage* _internal_mutable_skill_info();

  public:
  void clear_infos();
  InfosCase infos_case() const;
  // @@protoc_insertion_point(class_scope:SyncSkillMessage)
 private:
  class _Internal;
  void set_has_skill_info();
  inline bool has_infos() const;
  inline void clear_has_infos();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SyncSkillMessage& from_msg);
    ::uint64_t uid_;
    ::int32_t pos_;
    union InfosUnion {
      constexpr InfosUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::SkillInfoMessage* skill_info_;
    } infos_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class InputPacket final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:InputPacket) */ {
 public:
  inline InputPacket() : InputPacket(nullptr) {}
  ~InputPacket() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InputPacket* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InputPacket));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputPacket(
      ::google::protobuf::internal::ConstantInitialized);

  inline InputPacket(const InputPacket& from) : InputPacket(nullptr, from) {}
  inline InputPacket(InputPacket&& from) noexcept
      : InputPacket(nullptr, std::move(from)) {}
  inline InputPacket& operator=(const InputPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputPacket& operator=(InputPacket&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputPacket& default_instance() {
    return *internal_default_instance();
  }
  enum InputCase {
    kMove = 1,
    kPlayerAttack = 2,
    kExecuteSkill = 3,
    INPUT_NOT_SET = 0,
  };
  static inline const InputPacket* internal_default_instance() {
    return reinterpret_cast<const InputPacket*>(
        &_InputPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(InputPacket& a, InputPacket& b) { a.Swap(&b); }
  inline void Swap(InputPacket* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputPacket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputPacket* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InputPacket>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputPacket& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InputPacket& from) { InputPacket::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InputPacket* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "InputPacket"; }

 protected:
  explicit InputPacket(::google::protobuf::Arena* arena);
  InputPacket(::google::protobuf::Arena* arena, const InputPacket& from);
  InputPacket(::google::protobuf::Arena* arena, InputPacket&& from) noexcept
      : InputPacket(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMoveFieldNumber = 1,
    kPlayerAttackFieldNumber = 2,
    kExecuteSkillFieldNumber = 3,
  };
  // .MoveMessage move = 1;
  bool has_move() const;
  private:
  bool _internal_has_move() const;

  public:
  void clear_move() ;
  const ::MoveMessage& move() const;
  PROTOBUF_NODISCARD ::MoveMessage* release_move();
  ::MoveMessage* mutable_move();
  void set_allocated_move(::MoveMessage* value);
  void unsafe_arena_set_allocated_move(::MoveMessage* value);
  ::MoveMessage* unsafe_arena_release_move();

  private:
  const ::MoveMessage& _internal_move() const;
  ::MoveMessage* _internal_mutable_move();

  public:
  // .AttackMessage player_attack = 2;
  bool has_player_attack() const;
  private:
  bool _internal_has_player_attack() const;

  public:
  void clear_player_attack() ;
  const ::AttackMessage& player_attack() const;
  PROTOBUF_NODISCARD ::AttackMessage* release_player_attack();
  ::AttackMessage* mutable_player_attack();
  void set_allocated_player_attack(::AttackMessage* value);
  void unsafe_arena_set_allocated_player_attack(::AttackMessage* value);
  ::AttackMessage* unsafe_arena_release_player_attack();

  private:
  const ::AttackMessage& _internal_player_attack() const;
  ::AttackMessage* _internal_mutable_player_attack();

  public:
  // .ExecuteSkillMessage execute_skill = 3;
  bool has_execute_skill() const;
  private:
  bool _internal_has_execute_skill() const;

  public:
  void clear_execute_skill() ;
  const ::ExecuteSkillMessage& execute_skill() const;
  PROTOBUF_NODISCARD ::ExecuteSkillMessage* release_execute_skill();
  ::ExecuteSkillMessage* mutable_execute_skill();
  void set_allocated_execute_skill(::ExecuteSkillMessage* value);
  void unsafe_arena_set_allocated_execute_skill(::ExecuteSkillMessage* value);
  ::ExecuteSkillMessage* unsafe_arena_release_execute_skill();

  private:
  const ::ExecuteSkillMessage& _internal_execute_skill() const;
  ::ExecuteSkillMessage* _internal_mutable_execute_skill();

  public:
  void clear_input();
  InputCase input_case() const;
  // @@protoc_insertion_point(class_scope:InputPacket)
 private:
  class _Internal;
  void set_has_move();
  void set_has_player_attack();
  void set_has_execute_skill();
  inline bool has_input() const;
  inline void clear_has_input();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InputPacket& from_msg);
    union InputUnion {
      constexpr InputUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::MoveMessage* move_;
      ::AttackMessage* player_attack_;
      ::ExecuteSkillMessage* execute_skill_;
    } input_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class Packet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Packet) */ {
 public:
  inline Packet() : Packet(nullptr) {}
  ~Packet() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Packet* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Packet));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Packet(
      ::google::protobuf::internal::ConstantInitialized);

  inline Packet(const Packet& from) : Packet(nullptr, from) {}
  inline Packet(Packet&& from) noexcept
      : Packet(nullptr, std::move(from)) {}
  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Packet& operator=(Packet&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Packet& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kInput = 2,
    kPositionSync = 3,
    kPlayerSync = 4,
    kHealthSync = 5,
    kAttackSync = 6,
    kManaSync = 7,
    kAttackSpeedSync = 8,
    kSyncSkill = 9,
    kObjectsDestroyedSync = 10,
    MSG_NOT_SET = 0,
  };
  static inline const Packet* internal_default_instance() {
    return reinterpret_cast<const Packet*>(
        &_Packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Packet& a, Packet& b) { a.Swap(&b); }
  inline void Swap(Packet* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Packet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Packet* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Packet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Packet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Packet& from) { Packet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Packet* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Packet"; }

 protected:
  explicit Packet(::google::protobuf::Arena* arena);
  Packet(::google::protobuf::Arena* arena, const Packet& from);
  Packet(::google::protobuf::Arena* arena, Packet&& from) noexcept
      : Packet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputFieldNumber = 2,
    kPositionSyncFieldNumber = 3,
    kPlayerSyncFieldNumber = 4,
    kHealthSyncFieldNumber = 5,
    kAttackSyncFieldNumber = 6,
    kManaSyncFieldNumber = 7,
    kAttackSpeedSyncFieldNumber = 8,
    kSyncSkillFieldNumber = 9,
    kObjectsDestroyedSyncFieldNumber = 10,
  };
  // .InputPacket input = 2;
  bool has_input() const;
  private:
  bool _internal_has_input() const;

  public:
  void clear_input() ;
  const ::InputPacket& input() const;
  PROTOBUF_NODISCARD ::InputPacket* release_input();
  ::InputPacket* mutable_input();
  void set_allocated_input(::InputPacket* value);
  void unsafe_arena_set_allocated_input(::InputPacket* value);
  ::InputPacket* unsafe_arena_release_input();

  private:
  const ::InputPacket& _internal_input() const;
  ::InputPacket* _internal_mutable_input();

  public:
  // .PositionSyncMessage position_sync = 3;
  bool has_position_sync() const;
  private:
  bool _internal_has_position_sync() const;

  public:
  void clear_position_sync() ;
  const ::PositionSyncMessage& position_sync() const;
  PROTOBUF_NODISCARD ::PositionSyncMessage* release_position_sync();
  ::PositionSyncMessage* mutable_position_sync();
  void set_allocated_position_sync(::PositionSyncMessage* value);
  void unsafe_arena_set_allocated_position_sync(::PositionSyncMessage* value);
  ::PositionSyncMessage* unsafe_arena_release_position_sync();

  private:
  const ::PositionSyncMessage& _internal_position_sync() const;
  ::PositionSyncMessage* _internal_mutable_position_sync();

  public:
  // .PlayerSyncMessage player_sync = 4;
  bool has_player_sync() const;
  private:
  bool _internal_has_player_sync() const;

  public:
  void clear_player_sync() ;
  const ::PlayerSyncMessage& player_sync() const;
  PROTOBUF_NODISCARD ::PlayerSyncMessage* release_player_sync();
  ::PlayerSyncMessage* mutable_player_sync();
  void set_allocated_player_sync(::PlayerSyncMessage* value);
  void unsafe_arena_set_allocated_player_sync(::PlayerSyncMessage* value);
  ::PlayerSyncMessage* unsafe_arena_release_player_sync();

  private:
  const ::PlayerSyncMessage& _internal_player_sync() const;
  ::PlayerSyncMessage* _internal_mutable_player_sync();

  public:
  // .HealthSyncMessage health_sync = 5;
  bool has_health_sync() const;
  private:
  bool _internal_has_health_sync() const;

  public:
  void clear_health_sync() ;
  const ::HealthSyncMessage& health_sync() const;
  PROTOBUF_NODISCARD ::HealthSyncMessage* release_health_sync();
  ::HealthSyncMessage* mutable_health_sync();
  void set_allocated_health_sync(::HealthSyncMessage* value);
  void unsafe_arena_set_allocated_health_sync(::HealthSyncMessage* value);
  ::HealthSyncMessage* unsafe_arena_release_health_sync();

  private:
  const ::HealthSyncMessage& _internal_health_sync() const;
  ::HealthSyncMessage* _internal_mutable_health_sync();

  public:
  // .AttackSyncMessage attack_sync = 6;
  bool has_attack_sync() const;
  private:
  bool _internal_has_attack_sync() const;

  public:
  void clear_attack_sync() ;
  const ::AttackSyncMessage& attack_sync() const;
  PROTOBUF_NODISCARD ::AttackSyncMessage* release_attack_sync();
  ::AttackSyncMessage* mutable_attack_sync();
  void set_allocated_attack_sync(::AttackSyncMessage* value);
  void unsafe_arena_set_allocated_attack_sync(::AttackSyncMessage* value);
  ::AttackSyncMessage* unsafe_arena_release_attack_sync();

  private:
  const ::AttackSyncMessage& _internal_attack_sync() const;
  ::AttackSyncMessage* _internal_mutable_attack_sync();

  public:
  // .ManaSyncMessage mana_sync = 7;
  bool has_mana_sync() const;
  private:
  bool _internal_has_mana_sync() const;

  public:
  void clear_mana_sync() ;
  const ::ManaSyncMessage& mana_sync() const;
  PROTOBUF_NODISCARD ::ManaSyncMessage* release_mana_sync();
  ::ManaSyncMessage* mutable_mana_sync();
  void set_allocated_mana_sync(::ManaSyncMessage* value);
  void unsafe_arena_set_allocated_mana_sync(::ManaSyncMessage* value);
  ::ManaSyncMessage* unsafe_arena_release_mana_sync();

  private:
  const ::ManaSyncMessage& _internal_mana_sync() const;
  ::ManaSyncMessage* _internal_mutable_mana_sync();

  public:
  // .AttackSpeedSyncMessage attack_speed_sync = 8;
  bool has_attack_speed_sync() const;
  private:
  bool _internal_has_attack_speed_sync() const;

  public:
  void clear_attack_speed_sync() ;
  const ::AttackSpeedSyncMessage& attack_speed_sync() const;
  PROTOBUF_NODISCARD ::AttackSpeedSyncMessage* release_attack_speed_sync();
  ::AttackSpeedSyncMessage* mutable_attack_speed_sync();
  void set_allocated_attack_speed_sync(::AttackSpeedSyncMessage* value);
  void unsafe_arena_set_allocated_attack_speed_sync(::AttackSpeedSyncMessage* value);
  ::AttackSpeedSyncMessage* unsafe_arena_release_attack_speed_sync();

  private:
  const ::AttackSpeedSyncMessage& _internal_attack_speed_sync() const;
  ::AttackSpeedSyncMessage* _internal_mutable_attack_speed_sync();

  public:
  // .SyncSkillMessage sync_skill = 9;
  bool has_sync_skill() const;
  private:
  bool _internal_has_sync_skill() const;

  public:
  void clear_sync_skill() ;
  const ::SyncSkillMessage& sync_skill() const;
  PROTOBUF_NODISCARD ::SyncSkillMessage* release_sync_skill();
  ::SyncSkillMessage* mutable_sync_skill();
  void set_allocated_sync_skill(::SyncSkillMessage* value);
  void unsafe_arena_set_allocated_sync_skill(::SyncSkillMessage* value);
  ::SyncSkillMessage* unsafe_arena_release_sync_skill();

  private:
  const ::SyncSkillMessage& _internal_sync_skill() const;
  ::SyncSkillMessage* _internal_mutable_sync_skill();

  public:
  // .ObjectsDestroyedSyncMessage objects_destroyed_sync = 10;
  bool has_objects_destroyed_sync() const;
  private:
  bool _internal_has_objects_destroyed_sync() const;

  public:
  void clear_objects_destroyed_sync() ;
  const ::ObjectsDestroyedSyncMessage& objects_destroyed_sync() const;
  PROTOBUF_NODISCARD ::ObjectsDestroyedSyncMessage* release_objects_destroyed_sync();
  ::ObjectsDestroyedSyncMessage* mutable_objects_destroyed_sync();
  void set_allocated_objects_destroyed_sync(::ObjectsDestroyedSyncMessage* value);
  void unsafe_arena_set_allocated_objects_destroyed_sync(::ObjectsDestroyedSyncMessage* value);
  ::ObjectsDestroyedSyncMessage* unsafe_arena_release_objects_destroyed_sync();

  private:
  const ::ObjectsDestroyedSyncMessage& _internal_objects_destroyed_sync() const;
  ::ObjectsDestroyedSyncMessage* _internal_mutable_objects_destroyed_sync();

  public:
  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:Packet)
 private:
  class _Internal;
  void set_has_input();
  void set_has_position_sync();
  void set_has_player_sync();
  void set_has_health_sync();
  void set_has_attack_sync();
  void set_has_mana_sync();
  void set_has_attack_speed_sync();
  void set_has_sync_skill();
  void set_has_objects_destroyed_sync();
  inline bool has_msg() const;
  inline void clear_has_msg();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 9, 9,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Packet& from_msg);
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::InputPacket* input_;
      ::PositionSyncMessage* position_sync_;
      ::PlayerSyncMessage* player_sync_;
      ::HealthSyncMessage* health_sync_;
      ::AttackSyncMessage* attack_sync_;
      ::ManaSyncMessage* mana_sync_;
      ::AttackSpeedSyncMessage* attack_speed_sync_;
      ::SyncSkillMessage* sync_skill_;
      ::ObjectsDestroyedSyncMessage* objects_destroyed_sync_;
    } msg_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Packet

// .InputPacket input = 2;
inline bool Packet::has_input() const {
  return msg_case() == kInput;
}
inline bool Packet::_internal_has_input() const {
  return msg_case() == kInput;
}
inline void Packet::set_has_input() {
  _impl_._oneof_case_[0] = kInput;
}
inline void Packet::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kInput) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.input_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.input_);
    }
    clear_has_msg();
  }
}
inline ::InputPacket* Packet::release_input() {
  // @@protoc_insertion_point(field_release:Packet.input)
  if (msg_case() == kInput) {
    clear_has_msg();
    auto* temp = _impl_.msg_.input_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.input_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::InputPacket& Packet::_internal_input() const {
  return msg_case() == kInput ? *_impl_.msg_.input_ : reinterpret_cast<::InputPacket&>(::_InputPacket_default_instance_);
}
inline const ::InputPacket& Packet::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Packet.input)
  return _internal_input();
}
inline ::InputPacket* Packet::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.input)
  if (msg_case() == kInput) {
    clear_has_msg();
    auto* temp = _impl_.msg_.input_;
    _impl_.msg_.input_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_input(::InputPacket* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_input();
    _impl_.msg_.input_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.input)
}
inline ::InputPacket* Packet::_internal_mutable_input() {
  if (msg_case() != kInput) {
    clear_msg();
    set_has_input();
    _impl_.msg_.input_ =
        ::google::protobuf::Message::DefaultConstruct<::InputPacket>(GetArena());
  }
  return _impl_.msg_.input_;
}
inline ::InputPacket* Packet::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::InputPacket* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:Packet.input)
  return _msg;
}

// .PositionSyncMessage position_sync = 3;
inline bool Packet::has_position_sync() const {
  return msg_case() == kPositionSync;
}
inline bool Packet::_internal_has_position_sync() const {
  return msg_case() == kPositionSync;
}
inline void Packet::set_has_position_sync() {
  _impl_._oneof_case_[0] = kPositionSync;
}
inline void Packet::clear_position_sync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kPositionSync) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.position_sync_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.position_sync_);
    }
    clear_has_msg();
  }
}
inline ::PositionSyncMessage* Packet::release_position_sync() {
  // @@protoc_insertion_point(field_release:Packet.position_sync)
  if (msg_case() == kPositionSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.position_sync_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.position_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PositionSyncMessage& Packet::_internal_position_sync() const {
  return msg_case() == kPositionSync ? *_impl_.msg_.position_sync_ : reinterpret_cast<::PositionSyncMessage&>(::_PositionSyncMessage_default_instance_);
}
inline const ::PositionSyncMessage& Packet::position_sync() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Packet.position_sync)
  return _internal_position_sync();
}
inline ::PositionSyncMessage* Packet::unsafe_arena_release_position_sync() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.position_sync)
  if (msg_case() == kPositionSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.position_sync_;
    _impl_.msg_.position_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_position_sync(::PositionSyncMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_position_sync();
    _impl_.msg_.position_sync_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.position_sync)
}
inline ::PositionSyncMessage* Packet::_internal_mutable_position_sync() {
  if (msg_case() != kPositionSync) {
    clear_msg();
    set_has_position_sync();
    _impl_.msg_.position_sync_ =
        ::google::protobuf::Message::DefaultConstruct<::PositionSyncMessage>(GetArena());
  }
  return _impl_.msg_.position_sync_;
}
inline ::PositionSyncMessage* Packet::mutable_position_sync() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PositionSyncMessage* _msg = _internal_mutable_position_sync();
  // @@protoc_insertion_point(field_mutable:Packet.position_sync)
  return _msg;
}

// .PlayerSyncMessage player_sync = 4;
inline bool Packet::has_player_sync() const {
  return msg_case() == kPlayerSync;
}
inline bool Packet::_internal_has_player_sync() const {
  return msg_case() == kPlayerSync;
}
inline void Packet::set_has_player_sync() {
  _impl_._oneof_case_[0] = kPlayerSync;
}
inline void Packet::clear_player_sync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kPlayerSync) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.player_sync_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.player_sync_);
    }
    clear_has_msg();
  }
}
inline ::PlayerSyncMessage* Packet::release_player_sync() {
  // @@protoc_insertion_point(field_release:Packet.player_sync)
  if (msg_case() == kPlayerSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.player_sync_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.player_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PlayerSyncMessage& Packet::_internal_player_sync() const {
  return msg_case() == kPlayerSync ? *_impl_.msg_.player_sync_ : reinterpret_cast<::PlayerSyncMessage&>(::_PlayerSyncMessage_default_instance_);
}
inline const ::PlayerSyncMessage& Packet::player_sync() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Packet.player_sync)
  return _internal_player_sync();
}
inline ::PlayerSyncMessage* Packet::unsafe_arena_release_player_sync() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.player_sync)
  if (msg_case() == kPlayerSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.player_sync_;
    _impl_.msg_.player_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_player_sync(::PlayerSyncMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_player_sync();
    _impl_.msg_.player_sync_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.player_sync)
}
inline ::PlayerSyncMessage* Packet::_internal_mutable_player_sync() {
  if (msg_case() != kPlayerSync) {
    clear_msg();
    set_has_player_sync();
    _impl_.msg_.player_sync_ =
        ::google::protobuf::Message::DefaultConstruct<::PlayerSyncMessage>(GetArena());
  }
  return _impl_.msg_.player_sync_;
}
inline ::PlayerSyncMessage* Packet::mutable_player_sync() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PlayerSyncMessage* _msg = _internal_mutable_player_sync();
  // @@protoc_insertion_point(field_mutable:Packet.player_sync)
  return _msg;
}

// .HealthSyncMessage health_sync = 5;
inline bool Packet::has_health_sync() const {
  return msg_case() == kHealthSync;
}
inline bool Packet::_internal_has_health_sync() const {
  return msg_case() == kHealthSync;
}
inline void Packet::set_has_health_sync() {
  _impl_._oneof_case_[0] = kHealthSync;
}
inline void Packet::clear_health_sync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kHealthSync) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.health_sync_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.health_sync_);
    }
    clear_has_msg();
  }
}
inline ::HealthSyncMessage* Packet::release_health_sync() {
  // @@protoc_insertion_point(field_release:Packet.health_sync)
  if (msg_case() == kHealthSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.health_sync_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.health_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::HealthSyncMessage& Packet::_internal_health_sync() const {
  return msg_case() == kHealthSync ? *_impl_.msg_.health_sync_ : reinterpret_cast<::HealthSyncMessage&>(::_HealthSyncMessage_default_instance_);
}
inline const ::HealthSyncMessage& Packet::health_sync() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Packet.health_sync)
  return _internal_health_sync();
}
inline ::HealthSyncMessage* Packet::unsafe_arena_release_health_sync() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.health_sync)
  if (msg_case() == kHealthSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.health_sync_;
    _impl_.msg_.health_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_health_sync(::HealthSyncMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_health_sync();
    _impl_.msg_.health_sync_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.health_sync)
}
inline ::HealthSyncMessage* Packet::_internal_mutable_health_sync() {
  if (msg_case() != kHealthSync) {
    clear_msg();
    set_has_health_sync();
    _impl_.msg_.health_sync_ =
        ::google::protobuf::Message::DefaultConstruct<::HealthSyncMessage>(GetArena());
  }
  return _impl_.msg_.health_sync_;
}
inline ::HealthSyncMessage* Packet::mutable_health_sync() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HealthSyncMessage* _msg = _internal_mutable_health_sync();
  // @@protoc_insertion_point(field_mutable:Packet.health_sync)
  return _msg;
}

// .AttackSyncMessage attack_sync = 6;
inline bool Packet::has_attack_sync() const {
  return msg_case() == kAttackSync;
}
inline bool Packet::_internal_has_attack_sync() const {
  return msg_case() == kAttackSync;
}
inline void Packet::set_has_attack_sync() {
  _impl_._oneof_case_[0] = kAttackSync;
}
inline void Packet::clear_attack_sync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kAttackSync) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.attack_sync_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.attack_sync_);
    }
    clear_has_msg();
  }
}
inline ::AttackSyncMessage* Packet::release_attack_sync() {
  // @@protoc_insertion_point(field_release:Packet.attack_sync)
  if (msg_case() == kAttackSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.attack_sync_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.attack_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AttackSyncMessage& Packet::_internal_attack_sync() const {
  return msg_case() == kAttackSync ? *_impl_.msg_.attack_sync_ : reinterpret_cast<::AttackSyncMessage&>(::_AttackSyncMessage_default_instance_);
}
inline const ::AttackSyncMessage& Packet::attack_sync() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Packet.attack_sync)
  return _internal_attack_sync();
}
inline ::AttackSyncMessage* Packet::unsafe_arena_release_attack_sync() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.attack_sync)
  if (msg_case() == kAttackSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.attack_sync_;
    _impl_.msg_.attack_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_attack_sync(::AttackSyncMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_attack_sync();
    _impl_.msg_.attack_sync_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.attack_sync)
}
inline ::AttackSyncMessage* Packet::_internal_mutable_attack_sync() {
  if (msg_case() != kAttackSync) {
    clear_msg();
    set_has_attack_sync();
    _impl_.msg_.attack_sync_ =
        ::google::protobuf::Message::DefaultConstruct<::AttackSyncMessage>(GetArena());
  }
  return _impl_.msg_.attack_sync_;
}
inline ::AttackSyncMessage* Packet::mutable_attack_sync() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::AttackSyncMessage* _msg = _internal_mutable_attack_sync();
  // @@protoc_insertion_point(field_mutable:Packet.attack_sync)
  return _msg;
}

// .ManaSyncMessage mana_sync = 7;
inline bool Packet::has_mana_sync() const {
  return msg_case() == kManaSync;
}
inline bool Packet::_internal_has_mana_sync() const {
  return msg_case() == kManaSync;
}
inline void Packet::set_has_mana_sync() {
  _impl_._oneof_case_[0] = kManaSync;
}
inline void Packet::clear_mana_sync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kManaSync) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.mana_sync_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.mana_sync_);
    }
    clear_has_msg();
  }
}
inline ::ManaSyncMessage* Packet::release_mana_sync() {
  // @@protoc_insertion_point(field_release:Packet.mana_sync)
  if (msg_case() == kManaSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.mana_sync_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.mana_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ManaSyncMessage& Packet::_internal_mana_sync() const {
  return msg_case() == kManaSync ? *_impl_.msg_.mana_sync_ : reinterpret_cast<::ManaSyncMessage&>(::_ManaSyncMessage_default_instance_);
}
inline const ::ManaSyncMessage& Packet::mana_sync() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Packet.mana_sync)
  return _internal_mana_sync();
}
inline ::ManaSyncMessage* Packet::unsafe_arena_release_mana_sync() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.mana_sync)
  if (msg_case() == kManaSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.mana_sync_;
    _impl_.msg_.mana_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_mana_sync(::ManaSyncMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_mana_sync();
    _impl_.msg_.mana_sync_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.mana_sync)
}
inline ::ManaSyncMessage* Packet::_internal_mutable_mana_sync() {
  if (msg_case() != kManaSync) {
    clear_msg();
    set_has_mana_sync();
    _impl_.msg_.mana_sync_ =
        ::google::protobuf::Message::DefaultConstruct<::ManaSyncMessage>(GetArena());
  }
  return _impl_.msg_.mana_sync_;
}
inline ::ManaSyncMessage* Packet::mutable_mana_sync() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ManaSyncMessage* _msg = _internal_mutable_mana_sync();
  // @@protoc_insertion_point(field_mutable:Packet.mana_sync)
  return _msg;
}

// .AttackSpeedSyncMessage attack_speed_sync = 8;
inline bool Packet::has_attack_speed_sync() const {
  return msg_case() == kAttackSpeedSync;
}
inline bool Packet::_internal_has_attack_speed_sync() const {
  return msg_case() == kAttackSpeedSync;
}
inline void Packet::set_has_attack_speed_sync() {
  _impl_._oneof_case_[0] = kAttackSpeedSync;
}
inline void Packet::clear_attack_speed_sync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kAttackSpeedSync) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.attack_speed_sync_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.attack_speed_sync_);
    }
    clear_has_msg();
  }
}
inline ::AttackSpeedSyncMessage* Packet::release_attack_speed_sync() {
  // @@protoc_insertion_point(field_release:Packet.attack_speed_sync)
  if (msg_case() == kAttackSpeedSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.attack_speed_sync_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.attack_speed_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AttackSpeedSyncMessage& Packet::_internal_attack_speed_sync() const {
  return msg_case() == kAttackSpeedSync ? *_impl_.msg_.attack_speed_sync_ : reinterpret_cast<::AttackSpeedSyncMessage&>(::_AttackSpeedSyncMessage_default_instance_);
}
inline const ::AttackSpeedSyncMessage& Packet::attack_speed_sync() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Packet.attack_speed_sync)
  return _internal_attack_speed_sync();
}
inline ::AttackSpeedSyncMessage* Packet::unsafe_arena_release_attack_speed_sync() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.attack_speed_sync)
  if (msg_case() == kAttackSpeedSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.attack_speed_sync_;
    _impl_.msg_.attack_speed_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_attack_speed_sync(::AttackSpeedSyncMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_attack_speed_sync();
    _impl_.msg_.attack_speed_sync_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.attack_speed_sync)
}
inline ::AttackSpeedSyncMessage* Packet::_internal_mutable_attack_speed_sync() {
  if (msg_case() != kAttackSpeedSync) {
    clear_msg();
    set_has_attack_speed_sync();
    _impl_.msg_.attack_speed_sync_ =
        ::google::protobuf::Message::DefaultConstruct<::AttackSpeedSyncMessage>(GetArena());
  }
  return _impl_.msg_.attack_speed_sync_;
}
inline ::AttackSpeedSyncMessage* Packet::mutable_attack_speed_sync() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::AttackSpeedSyncMessage* _msg = _internal_mutable_attack_speed_sync();
  // @@protoc_insertion_point(field_mutable:Packet.attack_speed_sync)
  return _msg;
}

// .SyncSkillMessage sync_skill = 9;
inline bool Packet::has_sync_skill() const {
  return msg_case() == kSyncSkill;
}
inline bool Packet::_internal_has_sync_skill() const {
  return msg_case() == kSyncSkill;
}
inline void Packet::set_has_sync_skill() {
  _impl_._oneof_case_[0] = kSyncSkill;
}
inline void Packet::clear_sync_skill() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kSyncSkill) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.sync_skill_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.sync_skill_);
    }
    clear_has_msg();
  }
}
inline ::SyncSkillMessage* Packet::release_sync_skill() {
  // @@protoc_insertion_point(field_release:Packet.sync_skill)
  if (msg_case() == kSyncSkill) {
    clear_has_msg();
    auto* temp = _impl_.msg_.sync_skill_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.sync_skill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SyncSkillMessage& Packet::_internal_sync_skill() const {
  return msg_case() == kSyncSkill ? *_impl_.msg_.sync_skill_ : reinterpret_cast<::SyncSkillMessage&>(::_SyncSkillMessage_default_instance_);
}
inline const ::SyncSkillMessage& Packet::sync_skill() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Packet.sync_skill)
  return _internal_sync_skill();
}
inline ::SyncSkillMessage* Packet::unsafe_arena_release_sync_skill() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.sync_skill)
  if (msg_case() == kSyncSkill) {
    clear_has_msg();
    auto* temp = _impl_.msg_.sync_skill_;
    _impl_.msg_.sync_skill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_sync_skill(::SyncSkillMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_sync_skill();
    _impl_.msg_.sync_skill_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.sync_skill)
}
inline ::SyncSkillMessage* Packet::_internal_mutable_sync_skill() {
  if (msg_case() != kSyncSkill) {
    clear_msg();
    set_has_sync_skill();
    _impl_.msg_.sync_skill_ =
        ::google::protobuf::Message::DefaultConstruct<::SyncSkillMessage>(GetArena());
  }
  return _impl_.msg_.sync_skill_;
}
inline ::SyncSkillMessage* Packet::mutable_sync_skill() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SyncSkillMessage* _msg = _internal_mutable_sync_skill();
  // @@protoc_insertion_point(field_mutable:Packet.sync_skill)
  return _msg;
}

// .ObjectsDestroyedSyncMessage objects_destroyed_sync = 10;
inline bool Packet::has_objects_destroyed_sync() const {
  return msg_case() == kObjectsDestroyedSync;
}
inline bool Packet::_internal_has_objects_destroyed_sync() const {
  return msg_case() == kObjectsDestroyedSync;
}
inline void Packet::set_has_objects_destroyed_sync() {
  _impl_._oneof_case_[0] = kObjectsDestroyedSync;
}
inline void Packet::clear_objects_destroyed_sync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kObjectsDestroyedSync) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.objects_destroyed_sync_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.objects_destroyed_sync_);
    }
    clear_has_msg();
  }
}
inline ::ObjectsDestroyedSyncMessage* Packet::release_objects_destroyed_sync() {
  // @@protoc_insertion_point(field_release:Packet.objects_destroyed_sync)
  if (msg_case() == kObjectsDestroyedSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.objects_destroyed_sync_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.objects_destroyed_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ObjectsDestroyedSyncMessage& Packet::_internal_objects_destroyed_sync() const {
  return msg_case() == kObjectsDestroyedSync ? *_impl_.msg_.objects_destroyed_sync_ : reinterpret_cast<::ObjectsDestroyedSyncMessage&>(::_ObjectsDestroyedSyncMessage_default_instance_);
}
inline const ::ObjectsDestroyedSyncMessage& Packet::objects_destroyed_sync() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Packet.objects_destroyed_sync)
  return _internal_objects_destroyed_sync();
}
inline ::ObjectsDestroyedSyncMessage* Packet::unsafe_arena_release_objects_destroyed_sync() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.objects_destroyed_sync)
  if (msg_case() == kObjectsDestroyedSync) {
    clear_has_msg();
    auto* temp = _impl_.msg_.objects_destroyed_sync_;
    _impl_.msg_.objects_destroyed_sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_objects_destroyed_sync(::ObjectsDestroyedSyncMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_objects_destroyed_sync();
    _impl_.msg_.objects_destroyed_sync_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.objects_destroyed_sync)
}
inline ::ObjectsDestroyedSyncMessage* Packet::_internal_mutable_objects_destroyed_sync() {
  if (msg_case() != kObjectsDestroyedSync) {
    clear_msg();
    set_has_objects_destroyed_sync();
    _impl_.msg_.objects_destroyed_sync_ =
        ::google::protobuf::Message::DefaultConstruct<::ObjectsDestroyedSyncMessage>(GetArena());
  }
  return _impl_.msg_.objects_destroyed_sync_;
}
inline ::ObjectsDestroyedSyncMessage* Packet::mutable_objects_destroyed_sync() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ObjectsDestroyedSyncMessage* _msg = _internal_mutable_objects_destroyed_sync();
  // @@protoc_insertion_point(field_mutable:Packet.objects_destroyed_sync)
  return _msg;
}

inline bool Packet::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void Packet::clear_has_msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline Packet::MsgCase Packet::msg_case() const {
  return Packet::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InputPacket

// .MoveMessage move = 1;
inline bool InputPacket::has_move() const {
  return input_case() == kMove;
}
inline bool InputPacket::_internal_has_move() const {
  return input_case() == kMove;
}
inline void InputPacket::set_has_move() {
  _impl_._oneof_case_[0] = kMove;
}
inline void InputPacket::clear_move() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (input_case() == kMove) {
    if (GetArena() == nullptr) {
      delete _impl_.input_.move_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.input_.move_);
    }
    clear_has_input();
  }
}
inline ::MoveMessage* InputPacket::release_move() {
  // @@protoc_insertion_point(field_release:InputPacket.move)
  if (input_case() == kMove) {
    clear_has_input();
    auto* temp = _impl_.input_.move_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.input_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MoveMessage& InputPacket::_internal_move() const {
  return input_case() == kMove ? *_impl_.input_.move_ : reinterpret_cast<::MoveMessage&>(::_MoveMessage_default_instance_);
}
inline const ::MoveMessage& InputPacket::move() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InputPacket.move)
  return _internal_move();
}
inline ::MoveMessage* InputPacket::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:InputPacket.move)
  if (input_case() == kMove) {
    clear_has_input();
    auto* temp = _impl_.input_.move_;
    _impl_.input_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputPacket::unsafe_arena_set_allocated_move(::MoveMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_input();
  if (value) {
    set_has_move();
    _impl_.input_.move_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InputPacket.move)
}
inline ::MoveMessage* InputPacket::_internal_mutable_move() {
  if (input_case() != kMove) {
    clear_input();
    set_has_move();
    _impl_.input_.move_ =
        ::google::protobuf::Message::DefaultConstruct<::MoveMessage>(GetArena());
  }
  return _impl_.input_.move_;
}
inline ::MoveMessage* InputPacket::mutable_move() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::MoveMessage* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:InputPacket.move)
  return _msg;
}

// .AttackMessage player_attack = 2;
inline bool InputPacket::has_player_attack() const {
  return input_case() == kPlayerAttack;
}
inline bool InputPacket::_internal_has_player_attack() const {
  return input_case() == kPlayerAttack;
}
inline void InputPacket::set_has_player_attack() {
  _impl_._oneof_case_[0] = kPlayerAttack;
}
inline void InputPacket::clear_player_attack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (input_case() == kPlayerAttack) {
    if (GetArena() == nullptr) {
      delete _impl_.input_.player_attack_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.input_.player_attack_);
    }
    clear_has_input();
  }
}
inline ::AttackMessage* InputPacket::release_player_attack() {
  // @@protoc_insertion_point(field_release:InputPacket.player_attack)
  if (input_case() == kPlayerAttack) {
    clear_has_input();
    auto* temp = _impl_.input_.player_attack_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.input_.player_attack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AttackMessage& InputPacket::_internal_player_attack() const {
  return input_case() == kPlayerAttack ? *_impl_.input_.player_attack_ : reinterpret_cast<::AttackMessage&>(::_AttackMessage_default_instance_);
}
inline const ::AttackMessage& InputPacket::player_attack() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InputPacket.player_attack)
  return _internal_player_attack();
}
inline ::AttackMessage* InputPacket::unsafe_arena_release_player_attack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:InputPacket.player_attack)
  if (input_case() == kPlayerAttack) {
    clear_has_input();
    auto* temp = _impl_.input_.player_attack_;
    _impl_.input_.player_attack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputPacket::unsafe_arena_set_allocated_player_attack(::AttackMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_input();
  if (value) {
    set_has_player_attack();
    _impl_.input_.player_attack_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InputPacket.player_attack)
}
inline ::AttackMessage* InputPacket::_internal_mutable_player_attack() {
  if (input_case() != kPlayerAttack) {
    clear_input();
    set_has_player_attack();
    _impl_.input_.player_attack_ =
        ::google::protobuf::Message::DefaultConstruct<::AttackMessage>(GetArena());
  }
  return _impl_.input_.player_attack_;
}
inline ::AttackMessage* InputPacket::mutable_player_attack() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::AttackMessage* _msg = _internal_mutable_player_attack();
  // @@protoc_insertion_point(field_mutable:InputPacket.player_attack)
  return _msg;
}

// .ExecuteSkillMessage execute_skill = 3;
inline bool InputPacket::has_execute_skill() const {
  return input_case() == kExecuteSkill;
}
inline bool InputPacket::_internal_has_execute_skill() const {
  return input_case() == kExecuteSkill;
}
inline void InputPacket::set_has_execute_skill() {
  _impl_._oneof_case_[0] = kExecuteSkill;
}
inline void InputPacket::clear_execute_skill() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (input_case() == kExecuteSkill) {
    if (GetArena() == nullptr) {
      delete _impl_.input_.execute_skill_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.input_.execute_skill_);
    }
    clear_has_input();
  }
}
inline ::ExecuteSkillMessage* InputPacket::release_execute_skill() {
  // @@protoc_insertion_point(field_release:InputPacket.execute_skill)
  if (input_case() == kExecuteSkill) {
    clear_has_input();
    auto* temp = _impl_.input_.execute_skill_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.input_.execute_skill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ExecuteSkillMessage& InputPacket::_internal_execute_skill() const {
  return input_case() == kExecuteSkill ? *_impl_.input_.execute_skill_ : reinterpret_cast<::ExecuteSkillMessage&>(::_ExecuteSkillMessage_default_instance_);
}
inline const ::ExecuteSkillMessage& InputPacket::execute_skill() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InputPacket.execute_skill)
  return _internal_execute_skill();
}
inline ::ExecuteSkillMessage* InputPacket::unsafe_arena_release_execute_skill() {
  // @@protoc_insertion_point(field_unsafe_arena_release:InputPacket.execute_skill)
  if (input_case() == kExecuteSkill) {
    clear_has_input();
    auto* temp = _impl_.input_.execute_skill_;
    _impl_.input_.execute_skill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputPacket::unsafe_arena_set_allocated_execute_skill(::ExecuteSkillMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_input();
  if (value) {
    set_has_execute_skill();
    _impl_.input_.execute_skill_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InputPacket.execute_skill)
}
inline ::ExecuteSkillMessage* InputPacket::_internal_mutable_execute_skill() {
  if (input_case() != kExecuteSkill) {
    clear_input();
    set_has_execute_skill();
    _impl_.input_.execute_skill_ =
        ::google::protobuf::Message::DefaultConstruct<::ExecuteSkillMessage>(GetArena());
  }
  return _impl_.input_.execute_skill_;
}
inline ::ExecuteSkillMessage* InputPacket::mutable_execute_skill() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ExecuteSkillMessage* _msg = _internal_mutable_execute_skill();
  // @@protoc_insertion_point(field_mutable:InputPacket.execute_skill)
  return _msg;
}

inline bool InputPacket::has_input() const {
  return input_case() != INPUT_NOT_SET;
}
inline void InputPacket::clear_has_input() {
  _impl_._oneof_case_[0] = INPUT_NOT_SET;
}
inline InputPacket::InputCase InputPacket::input_case() const {
  return InputPacket::InputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MoveMessage

// float x = 1;
inline void MoveMessage::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float MoveMessage::x() const {
  // @@protoc_insertion_point(field_get:MoveMessage.x)
  return _internal_x();
}
inline void MoveMessage::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:MoveMessage.x)
}
inline float MoveMessage::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void MoveMessage::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void MoveMessage::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float MoveMessage::y() const {
  // @@protoc_insertion_point(field_get:MoveMessage.y)
  return _internal_y();
}
inline void MoveMessage::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:MoveMessage.y)
}
inline float MoveMessage::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void MoveMessage::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// AttackMessage

// uint64 uid = 1;
inline void AttackMessage::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = ::uint64_t{0u};
}
inline ::uint64_t AttackMessage::uid() const {
  // @@protoc_insertion_point(field_get:AttackMessage.uid)
  return _internal_uid();
}
inline void AttackMessage::set_uid(::uint64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:AttackMessage.uid)
}
inline ::uint64_t AttackMessage::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_;
}
inline void AttackMessage::_internal_set_uid(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = value;
}

// -------------------------------------------------------------------

// PlayerUseSkillMessage

// uint32 skill_pos = 1;
inline void PlayerUseSkillMessage::clear_skill_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skill_pos_ = 0u;
}
inline ::uint32_t PlayerUseSkillMessage::skill_pos() const {
  // @@protoc_insertion_point(field_get:PlayerUseSkillMessage.skill_pos)
  return _internal_skill_pos();
}
inline void PlayerUseSkillMessage::set_skill_pos(::uint32_t value) {
  _internal_set_skill_pos(value);
  // @@protoc_insertion_point(field_set:PlayerUseSkillMessage.skill_pos)
}
inline ::uint32_t PlayerUseSkillMessage::_internal_skill_pos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skill_pos_;
}
inline void PlayerUseSkillMessage::_internal_set_skill_pos(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skill_pos_ = value;
}

// uint64 target_player = 2;
inline void PlayerUseSkillMessage::clear_target_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_player_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerUseSkillMessage::target_player() const {
  // @@protoc_insertion_point(field_get:PlayerUseSkillMessage.target_player)
  return _internal_target_player();
}
inline void PlayerUseSkillMessage::set_target_player(::uint64_t value) {
  _internal_set_target_player(value);
  // @@protoc_insertion_point(field_set:PlayerUseSkillMessage.target_player)
}
inline ::uint64_t PlayerUseSkillMessage::_internal_target_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_player_;
}
inline void PlayerUseSkillMessage::_internal_set_target_player(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_player_ = value;
}

// float x = 3;
inline void PlayerUseSkillMessage::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float PlayerUseSkillMessage::x() const {
  // @@protoc_insertion_point(field_get:PlayerUseSkillMessage.x)
  return _internal_x();
}
inline void PlayerUseSkillMessage::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:PlayerUseSkillMessage.x)
}
inline float PlayerUseSkillMessage::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void PlayerUseSkillMessage::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 4;
inline void PlayerUseSkillMessage::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float PlayerUseSkillMessage::y() const {
  // @@protoc_insertion_point(field_get:PlayerUseSkillMessage.y)
  return _internal_y();
}
inline void PlayerUseSkillMessage::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:PlayerUseSkillMessage.y)
}
inline float PlayerUseSkillMessage::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void PlayerUseSkillMessage::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// PlayerSyncMessage

// uint64 uid = 1;
inline void PlayerSyncMessage::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerSyncMessage::uid() const {
  // @@protoc_insertion_point(field_get:PlayerSyncMessage.uid)
  return _internal_uid();
}
inline void PlayerSyncMessage::set_uid(::uint64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:PlayerSyncMessage.uid)
}
inline ::uint64_t PlayerSyncMessage::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_;
}
inline void PlayerSyncMessage::_internal_set_uid(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = value;
}

// bool self = 2;
inline void PlayerSyncMessage::clear_self() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.self_ = false;
}
inline bool PlayerSyncMessage::self() const {
  // @@protoc_insertion_point(field_get:PlayerSyncMessage.self)
  return _internal_self();
}
inline void PlayerSyncMessage::set_self(bool value) {
  _internal_set_self(value);
  // @@protoc_insertion_point(field_set:PlayerSyncMessage.self)
}
inline bool PlayerSyncMessage::_internal_self() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.self_;
}
inline void PlayerSyncMessage::_internal_set_self(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.self_ = value;
}

// -------------------------------------------------------------------

// ExitSyncMessage

// uint64 uid = 1;
inline void ExitSyncMessage::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = ::uint64_t{0u};
}
inline ::uint64_t ExitSyncMessage::uid() const {
  // @@protoc_insertion_point(field_get:ExitSyncMessage.uid)
  return _internal_uid();
}
inline void ExitSyncMessage::set_uid(::uint64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:ExitSyncMessage.uid)
}
inline ::uint64_t ExitSyncMessage::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_;
}
inline void ExitSyncMessage::_internal_set_uid(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = value;
}

// -------------------------------------------------------------------

// PositionSyncMessage

// uint64 id = 1;
inline void PositionSyncMessage::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t PositionSyncMessage::id() const {
  // @@protoc_insertion_point(field_get:PositionSyncMessage.id)
  return _internal_id();
}
inline void PositionSyncMessage::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:PositionSyncMessage.id)
}
inline ::uint64_t PositionSyncMessage::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void PositionSyncMessage::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// float pos_x = 2;
inline void PositionSyncMessage::clear_pos_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pos_x_ = 0;
}
inline float PositionSyncMessage::pos_x() const {
  // @@protoc_insertion_point(field_get:PositionSyncMessage.pos_x)
  return _internal_pos_x();
}
inline void PositionSyncMessage::set_pos_x(float value) {
  _internal_set_pos_x(value);
  // @@protoc_insertion_point(field_set:PositionSyncMessage.pos_x)
}
inline float PositionSyncMessage::_internal_pos_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pos_x_;
}
inline void PositionSyncMessage::_internal_set_pos_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pos_x_ = value;
}

// float pos_y = 3;
inline void PositionSyncMessage::clear_pos_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pos_y_ = 0;
}
inline float PositionSyncMessage::pos_y() const {
  // @@protoc_insertion_point(field_get:PositionSyncMessage.pos_y)
  return _internal_pos_y();
}
inline void PositionSyncMessage::set_pos_y(float value) {
  _internal_set_pos_y(value);
  // @@protoc_insertion_point(field_set:PositionSyncMessage.pos_y)
}
inline float PositionSyncMessage::_internal_pos_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pos_y_;
}
inline void PositionSyncMessage::_internal_set_pos_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pos_y_ = value;
}

// -------------------------------------------------------------------

// HealthSyncMessage

// uint64 uid = 1;
inline void HealthSyncMessage::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = ::uint64_t{0u};
}
inline ::uint64_t HealthSyncMessage::uid() const {
  // @@protoc_insertion_point(field_get:HealthSyncMessage.uid)
  return _internal_uid();
}
inline void HealthSyncMessage::set_uid(::uint64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:HealthSyncMessage.uid)
}
inline ::uint64_t HealthSyncMessage::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_;
}
inline void HealthSyncMessage::_internal_set_uid(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = value;
}

// int32 health = 2;
inline void HealthSyncMessage::clear_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ = 0;
}
inline ::int32_t HealthSyncMessage::health() const {
  // @@protoc_insertion_point(field_get:HealthSyncMessage.health)
  return _internal_health();
}
inline void HealthSyncMessage::set_health(::int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:HealthSyncMessage.health)
}
inline ::int32_t HealthSyncMessage::_internal_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_;
}
inline void HealthSyncMessage::_internal_set_health(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ = value;
}

// int32 max_health = 3;
inline void HealthSyncMessage::clear_max_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_health_ = 0;
}
inline ::int32_t HealthSyncMessage::max_health() const {
  // @@protoc_insertion_point(field_get:HealthSyncMessage.max_health)
  return _internal_max_health();
}
inline void HealthSyncMessage::set_max_health(::int32_t value) {
  _internal_set_max_health(value);
  // @@protoc_insertion_point(field_set:HealthSyncMessage.max_health)
}
inline ::int32_t HealthSyncMessage::_internal_max_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_health_;
}
inline void HealthSyncMessage::_internal_set_max_health(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_health_ = value;
}

// -------------------------------------------------------------------

// AttackSyncMessage

// uint64 from = 1;
inline void AttackSyncMessage::clear_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_ = ::uint64_t{0u};
}
inline ::uint64_t AttackSyncMessage::from() const {
  // @@protoc_insertion_point(field_get:AttackSyncMessage.from)
  return _internal_from();
}
inline void AttackSyncMessage::set_from(::uint64_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:AttackSyncMessage.from)
}
inline ::uint64_t AttackSyncMessage::_internal_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_;
}
inline void AttackSyncMessage::_internal_set_from(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_ = value;
}

// uint64 to = 2;
inline void AttackSyncMessage::clear_to() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_ = ::uint64_t{0u};
}
inline ::uint64_t AttackSyncMessage::to() const {
  // @@protoc_insertion_point(field_get:AttackSyncMessage.to)
  return _internal_to();
}
inline void AttackSyncMessage::set_to(::uint64_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:AttackSyncMessage.to)
}
inline ::uint64_t AttackSyncMessage::_internal_to() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_;
}
inline void AttackSyncMessage::_internal_set_to(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_ = value;
}

// float cool_down = 3;
inline void AttackSyncMessage::clear_cool_down() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cool_down_ = 0;
}
inline float AttackSyncMessage::cool_down() const {
  // @@protoc_insertion_point(field_get:AttackSyncMessage.cool_down)
  return _internal_cool_down();
}
inline void AttackSyncMessage::set_cool_down(float value) {
  _internal_set_cool_down(value);
  // @@protoc_insertion_point(field_set:AttackSyncMessage.cool_down)
}
inline float AttackSyncMessage::_internal_cool_down() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cool_down_;
}
inline void AttackSyncMessage::_internal_set_cool_down(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cool_down_ = value;
}

// -------------------------------------------------------------------

// ManaSyncMessage

// uint64 uid = 1;
inline void ManaSyncMessage::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = ::uint64_t{0u};
}
inline ::uint64_t ManaSyncMessage::uid() const {
  // @@protoc_insertion_point(field_get:ManaSyncMessage.uid)
  return _internal_uid();
}
inline void ManaSyncMessage::set_uid(::uint64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:ManaSyncMessage.uid)
}
inline ::uint64_t ManaSyncMessage::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_;
}
inline void ManaSyncMessage::_internal_set_uid(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = value;
}

// int32 mana = 2;
inline void ManaSyncMessage::clear_mana() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mana_ = 0;
}
inline ::int32_t ManaSyncMessage::mana() const {
  // @@protoc_insertion_point(field_get:ManaSyncMessage.mana)
  return _internal_mana();
}
inline void ManaSyncMessage::set_mana(::int32_t value) {
  _internal_set_mana(value);
  // @@protoc_insertion_point(field_set:ManaSyncMessage.mana)
}
inline ::int32_t ManaSyncMessage::_internal_mana() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mana_;
}
inline void ManaSyncMessage::_internal_set_mana(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mana_ = value;
}

// int32 max_mana = 3;
inline void ManaSyncMessage::clear_max_mana() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_mana_ = 0;
}
inline ::int32_t ManaSyncMessage::max_mana() const {
  // @@protoc_insertion_point(field_get:ManaSyncMessage.max_mana)
  return _internal_max_mana();
}
inline void ManaSyncMessage::set_max_mana(::int32_t value) {
  _internal_set_max_mana(value);
  // @@protoc_insertion_point(field_set:ManaSyncMessage.max_mana)
}
inline ::int32_t ManaSyncMessage::_internal_max_mana() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_mana_;
}
inline void ManaSyncMessage::_internal_set_max_mana(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_mana_ = value;
}

// -------------------------------------------------------------------

// AttackSpeedSyncMessage

// uint64 uid = 1;
inline void AttackSpeedSyncMessage::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = ::uint64_t{0u};
}
inline ::uint64_t AttackSpeedSyncMessage::uid() const {
  // @@protoc_insertion_point(field_get:AttackSpeedSyncMessage.uid)
  return _internal_uid();
}
inline void AttackSpeedSyncMessage::set_uid(::uint64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:AttackSpeedSyncMessage.uid)
}
inline ::uint64_t AttackSpeedSyncMessage::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_;
}
inline void AttackSpeedSyncMessage::_internal_set_uid(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = value;
}

// float speed = 2;
inline void AttackSpeedSyncMessage::clear_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = 0;
}
inline float AttackSpeedSyncMessage::speed() const {
  // @@protoc_insertion_point(field_get:AttackSpeedSyncMessage.speed)
  return _internal_speed();
}
inline void AttackSpeedSyncMessage::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:AttackSpeedSyncMessage.speed)
}
inline float AttackSpeedSyncMessage::_internal_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_;
}
inline void AttackSpeedSyncMessage::_internal_set_speed(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = value;
}

// -------------------------------------------------------------------

// ExecuteSkillMessage

// float rotate = 1;
inline void ExecuteSkillMessage::clear_rotate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rotate_ = 0;
}
inline float ExecuteSkillMessage::rotate() const {
  // @@protoc_insertion_point(field_get:ExecuteSkillMessage.rotate)
  return _internal_rotate();
}
inline void ExecuteSkillMessage::set_rotate(float value) {
  _internal_set_rotate(value);
  // @@protoc_insertion_point(field_set:ExecuteSkillMessage.rotate)
}
inline float ExecuteSkillMessage::_internal_rotate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rotate_;
}
inline void ExecuteSkillMessage::_internal_set_rotate(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rotate_ = value;
}

// float pos_x = 2;
inline void ExecuteSkillMessage::clear_pos_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pos_x_ = 0;
}
inline float ExecuteSkillMessage::pos_x() const {
  // @@protoc_insertion_point(field_get:ExecuteSkillMessage.pos_x)
  return _internal_pos_x();
}
inline void ExecuteSkillMessage::set_pos_x(float value) {
  _internal_set_pos_x(value);
  // @@protoc_insertion_point(field_set:ExecuteSkillMessage.pos_x)
}
inline float ExecuteSkillMessage::_internal_pos_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pos_x_;
}
inline void ExecuteSkillMessage::_internal_set_pos_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pos_x_ = value;
}

// float pos_y = 3;
inline void ExecuteSkillMessage::clear_pos_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pos_y_ = 0;
}
inline float ExecuteSkillMessage::pos_y() const {
  // @@protoc_insertion_point(field_get:ExecuteSkillMessage.pos_y)
  return _internal_pos_y();
}
inline void ExecuteSkillMessage::set_pos_y(float value) {
  _internal_set_pos_y(value);
  // @@protoc_insertion_point(field_set:ExecuteSkillMessage.pos_y)
}
inline float ExecuteSkillMessage::_internal_pos_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pos_y_;
}
inline void ExecuteSkillMessage::_internal_set_pos_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pos_y_ = value;
}

// -------------------------------------------------------------------

// SyncSkillMessage

// uint64 uid = 1;
inline void SyncSkillMessage::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = ::uint64_t{0u};
}
inline ::uint64_t SyncSkillMessage::uid() const {
  // @@protoc_insertion_point(field_get:SyncSkillMessage.uid)
  return _internal_uid();
}
inline void SyncSkillMessage::set_uid(::uint64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:SyncSkillMessage.uid)
}
inline ::uint64_t SyncSkillMessage::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_;
}
inline void SyncSkillMessage::_internal_set_uid(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = value;
}

// int32 pos = 2;
inline void SyncSkillMessage::clear_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pos_ = 0;
}
inline ::int32_t SyncSkillMessage::pos() const {
  // @@protoc_insertion_point(field_get:SyncSkillMessage.pos)
  return _internal_pos();
}
inline void SyncSkillMessage::set_pos(::int32_t value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:SyncSkillMessage.pos)
}
inline ::int32_t SyncSkillMessage::_internal_pos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pos_;
}
inline void SyncSkillMessage::_internal_set_pos(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pos_ = value;
}

// .SkillInfoMessage skill_info = 3;
inline bool SyncSkillMessage::has_skill_info() const {
  return infos_case() == kSkillInfo;
}
inline bool SyncSkillMessage::_internal_has_skill_info() const {
  return infos_case() == kSkillInfo;
}
inline void SyncSkillMessage::set_has_skill_info() {
  _impl_._oneof_case_[0] = kSkillInfo;
}
inline void SyncSkillMessage::clear_skill_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (infos_case() == kSkillInfo) {
    if (GetArena() == nullptr) {
      delete _impl_.infos_.skill_info_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.infos_.skill_info_);
    }
    clear_has_infos();
  }
}
inline ::SkillInfoMessage* SyncSkillMessage::release_skill_info() {
  // @@protoc_insertion_point(field_release:SyncSkillMessage.skill_info)
  if (infos_case() == kSkillInfo) {
    clear_has_infos();
    auto* temp = _impl_.infos_.skill_info_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.infos_.skill_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SkillInfoMessage& SyncSkillMessage::_internal_skill_info() const {
  return infos_case() == kSkillInfo ? *_impl_.infos_.skill_info_ : reinterpret_cast<::SkillInfoMessage&>(::_SkillInfoMessage_default_instance_);
}
inline const ::SkillInfoMessage& SyncSkillMessage::skill_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SyncSkillMessage.skill_info)
  return _internal_skill_info();
}
inline ::SkillInfoMessage* SyncSkillMessage::unsafe_arena_release_skill_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SyncSkillMessage.skill_info)
  if (infos_case() == kSkillInfo) {
    clear_has_infos();
    auto* temp = _impl_.infos_.skill_info_;
    _impl_.infos_.skill_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SyncSkillMessage::unsafe_arena_set_allocated_skill_info(::SkillInfoMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_infos();
  if (value) {
    set_has_skill_info();
    _impl_.infos_.skill_info_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SyncSkillMessage.skill_info)
}
inline ::SkillInfoMessage* SyncSkillMessage::_internal_mutable_skill_info() {
  if (infos_case() != kSkillInfo) {
    clear_infos();
    set_has_skill_info();
    _impl_.infos_.skill_info_ =
        ::google::protobuf::Message::DefaultConstruct<::SkillInfoMessage>(GetArena());
  }
  return _impl_.infos_.skill_info_;
}
inline ::SkillInfoMessage* SyncSkillMessage::mutable_skill_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SkillInfoMessage* _msg = _internal_mutable_skill_info();
  // @@protoc_insertion_point(field_mutable:SyncSkillMessage.skill_info)
  return _msg;
}

inline bool SyncSkillMessage::has_infos() const {
  return infos_case() != INFOS_NOT_SET;
}
inline void SyncSkillMessage::clear_has_infos() {
  _impl_._oneof_case_[0] = INFOS_NOT_SET;
}
inline SyncSkillMessage::InfosCase SyncSkillMessage::infos_case() const {
  return SyncSkillMessage::InfosCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SkillInfoMessage

// uint64 id = 1;
inline void SkillInfoMessage::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t SkillInfoMessage::id() const {
  // @@protoc_insertion_point(field_get:SkillInfoMessage.id)
  return _internal_id();
}
inline void SkillInfoMessage::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:SkillInfoMessage.id)
}
inline ::uint64_t SkillInfoMessage::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void SkillInfoMessage::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// float angle = 4;
inline void SkillInfoMessage::clear_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angle_ = 0;
}
inline float SkillInfoMessage::angle() const {
  // @@protoc_insertion_point(field_get:SkillInfoMessage.angle)
  return _internal_angle();
}
inline void SkillInfoMessage::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:SkillInfoMessage.angle)
}
inline float SkillInfoMessage::_internal_angle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.angle_;
}
inline void SkillInfoMessage::_internal_set_angle(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// ObjectsDestroyedSyncMessage

// uint64 id = 1;
inline void ObjectsDestroyedSyncMessage::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t ObjectsDestroyedSyncMessage::id() const {
  // @@protoc_insertion_point(field_get:ObjectsDestroyedSyncMessage.id)
  return _internal_id();
}
inline void ObjectsDestroyedSyncMessage::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ObjectsDestroyedSyncMessage.id)
}
inline ::uint64_t ObjectsDestroyedSyncMessage::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void ObjectsDestroyedSyncMessage::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // test_2eproto_2epb_2eh
